"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[9460],{88330:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var a=t(85893),i=t(11151);const s={title:"Final states"},r=void 0,l={id:"final-states",title:"Final states",description:"A final state is a state that represents the completion or successful termination of a machine. It is defined by the type",source:"@site/docs/final-states.mdx",sourceDirName:".",slug:"/final-states",permalink:"/xstate-zh/docs/final-states",draft:!1,unlisted:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/final-states.mdx",tags:[],version:"current",frontMatter:{title:"Final states"},sidebar:"tutorialSidebar",previous:{title:"Parallel states",permalink:"/xstate-zh/docs/parallel-states"},next:{title:"History states",permalink:"/xstate-zh/docs/history-states"}},c={},o=[{value:"Top-level final states",id:"top-level-final-states",level:2},{value:"Child final states",id:"child-final-states",level:2},{value:"Final states in parallel states",id:"final-states-in-parallel-states",level:2},{value:"Output",id:"output",level:2},{value:"Final states cheatsheet",id:"final-states-cheatsheet",level:2},{value:"Cheatsheet: final states in parallel states",id:"cheatsheet-final-states-in-parallel-states",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components},{EmbedMachine:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("EmbedMachine",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["A final state is a state that represents the completion or successful termination of a machine. It is defined by the ",(0,a.jsx)(n.code,{children:"type: 'final'"})," property on a state node:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    prompt: {\n      /* ... */\n    },\n    thanks: {\n      /* ... */\n    },\n    // highlight-start\n    closed: {\n      type: 'final',\n    },\n    // highlight-end\n    // ...\n  },\n  on: {\n    'feedback.close': {\n      target: '.closed',\n    },\n  },\n});\n"})}),"\n",(0,a.jsx)(t,{embedURL:"https://stately.ai/registry/editor/embed/c447d996-cef1-421d-a422-8be695668764?mode=design&machineId=7d3feeca-1017-4d94-87b3-cd5128682440",title:"Feedback machine with final state"}),"\n",(0,a.jsx)(n.p,{children:"When a machine reaches the final state, it can no longer receive any events, and anything running inside it is canceled and cleaned up. The box with a surrounding border icon represents the final state."}),"\n",(0,a.jsx)(n.p,{children:"A machine can have multiple final states or no final states."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"A state machine can have zero or more final states. Some machines may run indefinitely and not need to terminate."}),"\n",(0,a.jsxs)(n.li,{children:["Final states can have ",(0,a.jsx)(n.code,{children:"output"})," data, which is sent to the parent machine when the machine terminates."]}),"\n",(0,a.jsx)(n.li,{children:"When a machine reaches a top-level final state, it terminates."}),"\n",(0,a.jsx)(n.li,{children:"Final states cannot have transitions"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"top-level-final-states",children:"Top-level final states"}),"\n",(0,a.jsx)(n.p,{children:"A top-level final state is a final state that is a direct child state of the machine. When the machine reaches a top-level final state, the machine will terminate. When a machine terminates, it can no longer receive events nor transition."}),"\n",(0,a.jsx)(n.h2,{id:"child-final-states",children:"Child final states"}),"\n",(0,a.jsxs)(n.p,{children:["When a child final state of a ",(0,a.jsx)(n.a,{href:"/xstate-zh/docs/parent-states",children:"parent (compound) state"}),' is reached, that parent state is considered "done". The ',(0,a.jsx)(n.code,{children:"onDone"})," transition of that parent state is automatically taken."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine } from 'xstate';\n\nconst coffeeMachine = createMachine({\n  initial: 'preparation',\n  states: {\n    preparation: {\n      initial: 'weighing',\n      states: {\n        weighing: {\n          on: {\n            weighed: {\n              target: 'grinding'\n            }\n          }\n        },\n        grinding: {\n          on: {\n            ground: 'ready'\n          }\n        },\n        // highlight-start\n        ready: {\n          // Child final state of parent state 'preparation'\n          type: 'final'\n        }\n        // highlight-end\n      },\n      // highlight-start\n      // Transition will be taken when child final state is reached\n      onDone: {\n        target: 'brewing'\n      }\n      // highlight-end\n    },\n    brewing: {\n      // ...\n    }\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"final-states-in-parallel-states",children:"Final states in parallel states"}),"\n",(0,a.jsxs)(n.p,{children:['When all regions of a parallel state are "done", the parallel state is considered "done". The ',(0,a.jsx)(n.code,{children:"onDone"})," transition of the parallel state is taken."]}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the ",(0,a.jsx)(n.code,{children:"preparation"})," state is a parallel state with two regions: ",(0,a.jsx)(n.code,{children:"beans"})," and ",(0,a.jsx)(n.code,{children:"water"}),". When both regions are done, the ",(0,a.jsx)(n.code,{children:"preparation"})," state is done, and the ",(0,a.jsx)(n.code,{children:"brewing"})," state is entered."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine, createActor } from 'xstate';\n\nconst coffeeMachine = createMachine({\n  initial: 'preparation',\n  states: {\n    preparation: {\n      type: 'parallel',\n      states: {\n        beans: {\n          initial: 'grinding',\n          states: {\n            grinding: {\n              on: {\n                grindingComplete: 'ground',\n              },\n            },\n            // highlight-start\n            ground: {\n              type: 'final',\n            },\n            // highlight-end\n          },\n        },\n        water: {\n          initial: 'heating',\n          states: {\n            heating: {\n              always: {\n                guard: 'waterBoiling',\n                target: 'heated',\n              },\n            },\n            // highlight-start\n            heated: {\n              type: 'final',\n            },\n            // highlight-end\n          },\n        },\n      },\n      // highlight-next-line\n      onDone: 'brewing',\n    },\n    brewing: {},\n  },\n});\n"})}),"\n",(0,a.jsx)(t,{embedURL:"https://stately.ai/registry/editor/embed/c447d996-cef1-421d-a422-8be695668764?mode=design&machineId=95504ba2-3da2-4d70-a3b5-59bbcd31bf2d",title:"Coffee machine with final states"}),"\n",(0,a.jsx)(n.h2,{id:"output",children:"Output"}),"\n",(0,a.jsxs)(n.p,{children:["When a machine reaches its top-level final state, it can produce output data. You can specify this output data in the ",(0,a.jsx)(n.code,{children:".output"})," property of the machine config:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine, createActor } from 'xstate';\n\nconst currencyMachine = createMachine({\n  // ...\n  states: {\n    converting: {\n      // ...\n    },\n    converted: {\n      type: 'final',\n    },\n  },\n  // highlight-start\n  output: ({ context }) => ({\n    amount: context.amount,\n    currency: context.currency,\n  }),\n  // highlight-end\n});\n\nconst currencyActor = createActor(currencyMachine, {\n  input: {\n    amount: 10,\n    fromCurrency: 'USD',\n    toCurrency: 'EUR',\n  },\n});\n\ncurrencyActor.subscribe({\n  complete() {\n    console.log(currencyActor.getSnapshot().output);\n    // logs e.g. { amount: 12, currency: 'EUR' }\n  },\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:".output"})," property can also be a static value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine, createActor } from 'xstate';\n\nconst processMachine = createMachine({\n  // ...\n  output: {\n    message: 'Process completed.',\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"final-states-cheatsheet",children:"Final states cheatsheet"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    prompt: {\n      /* ... */\n    },\n    thanks: {\n      /* ... */\n    },\n    // highlight-start\n    closed: {\n      type: 'final',\n    },\n    // highlight-end\n    // ...\n  },\n  on: {\n    'feedback.close': {\n      target: '.closed',\n    },\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cheatsheet-final-states-in-parallel-states",children:"Cheatsheet: final states in parallel states"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine} from 'xstate';\n\nconst coffeeMachine = createMachine({\n  initial: 'preparation',\n  states: {\n    preparation: {\n      type: 'parallel',\n      states: {\n        beans: {\n          initial: 'grinding',\n          states: {\n            grinding: {\n              on: {\n                grindingComplete: 'ground',\n              },\n            },\n            // highlight-start\n            ground: {\n              type: 'final',\n            },\n            // highlight-end\n          },\n        },\n        water: {\n          initial: 'heating',\n          states: {\n            heating: {\n              always: {\n                guard: 'waterBoiling',\n                target: 'heated',\n              },\n            },\n            // highlight-start\n            heated: {\n              type: 'final',\n            },\n            // highlight-end\n          },\n        },\n      },\n      // highlight-next-line\n      onDone: 'brewing',\n    },\n    brewing: {},\n  },\n});\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>r});var a=t(67294);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);