"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[309],{45209:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var a=s(85893),n=s(11151);const i={title:"Glossary"},r=void 0,o={id:"glossary",title:"Glossary",description:"This glossary is an alphabetical guide to the most common terms in statecharts and state machines.",source:"@site/docs/glossary.mdx",sourceDirName:".",slug:"/glossary",permalink:"/xstate-zh/docs/glossary",draft:!1,unlisted:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/glossary.mdx",tags:[],version:"current",frontMatter:{title:"Glossary"},sidebar:"tutorialSidebar",previous:{title:"Developer tools",permalink:"/xstate-zh/docs/developer-tools"}},c={},h=[{value:"Actions",id:"actions",level:2},{value:"Actors",id:"actors",level:2},{value:"After transitions",id:"after-transitions",level:2},{value:"Always transitions",id:"always-transitions",level:2},{value:"Compound states",id:"compound-states",level:2},{value:"Context",id:"context",level:2},{value:"Delayed transitions",id:"delayed-transitions",level:2},{value:"Eventless transitions",id:"eventless-transitions",level:2},{value:"Final state",id:"final-state",level:2},{value:"Guards",id:"guards",level:2},{value:"History state",id:"history-state",level:2},{value:"Initial state",id:"initial-state",level:2},{value:"Invoked actors",id:"invoked-actors",level:2},{value:"Parallel states",id:"parallel-states",level:2},{value:"Parent and child states",id:"parent-and-child-states",level:2},{value:"States",id:"states",level:2},{value:"Statecharts",id:"statecharts",level:2},{value:"State machines",id:"state-machines",level:2},{value:"Transitions and events",id:"transitions-and-events",level:2}];function l(e){const t={a:"a",admonition:"admonition",em:"em",h2:"h2",p:"p",strong:"strong",...(0,n.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"This glossary is an alphabetical guide to the most common terms in statecharts and state machines."}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["Looking for more detailed information on these concepts? ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/state-machines-and-statecharts",children:"Read the introduction to state machines and statecharts"}),"."]})}),"\n",(0,a.jsx)(t.h2,{id:"actions",children:"Actions"}),"\n",(0,a.jsxs)(t.p,{children:["An ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/actions",children:"action"})," is an effect that is executed during a state transition. Actions are \u201cfire-and-forget effects\u201d; once the machine has fired the action, it moves on and forgets the action."]}),"\n",(0,a.jsx)(t.h2,{id:"actors",children:"Actors"}),"\n",(0,a.jsxs)(t.p,{children:["When you run a state machine, it becomes an ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/actors",children:"actor"}),", which is a running process that can receive events, send events, and change its behavior based on the events it receives, which can cause effects outside of the actor."]}),"\n",(0,a.jsx)(t.h2,{id:"after-transitions",children:"After transitions"}),"\n",(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"/#delayed-transitions",children:"delayed transitions"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"always-transitions",children:"Always transitions"}),"\n",(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"/#eventless-transitions",children:"eventless transitions"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"compound-states",children:"Compound states"}),"\n",(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"/#parent-and-child-states",children:"parent and child states"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/xstate-zh/docs/context",children:"Context"})," is the place that contextual data is stored in a state machine actor."]}),"\n",(0,a.jsx)(t.h2,{id:"delayed-transitions",children:"Delayed transitions"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/xstate-zh/docs/delayed-transitions",children:"Delayed transitions"}),"\xa0are transitions that only happen after a specified interval of time. If another event happens before the end of the timer, the transition doesn\u2019t complete. Delayed transitions are labeled \u201cafter\u201d and often referred to as \u201cafter\u201d transitions."]}),"\n",(0,a.jsx)(t.h2,{id:"eventless-transitions",children:"Eventless transitions"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/xstate-zh/docs/eventless-transitions",children:"Eventless transitions"}),"\xa0are transitions without events. These transitions are\xa0",(0,a.jsx)(t.em,{children:"always"}),"\xa0taken after any transition in their state is enabled. No event is necessary to trigger the transition. Eventless transitions are labeled \u201calways\u201d and often referred to as \u201calways\u201d transitions."]}),"\n",(0,a.jsx)(t.h2,{id:"final-state",children:"Final state"}),"\n",(0,a.jsxs)(t.p,{children:["When a machine reaches the ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/final-states",children:"final state"}),", it can no longer receive any events, and anything running inside it is canceled and cleaned up. A machine can have multiple final states or no final states."]}),"\n",(0,a.jsx)(t.h2,{id:"guards",children:"Guards"}),"\n",(0,a.jsxs)(t.p,{children:["A\xa0",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/guards",children:"guard"}),"\xa0is a condition that the machine checks when it goes through an event. If the condition is true, the machine follows the transition to the next state. If the condition is false, the machine follows the rest of the conditions to the next state. Any transition can be a guarded transition."]}),"\n",(0,a.jsx)(t.h2,{id:"history-state",children:"History state"}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/history-states",children:"history state"})," returns the parent state to its most recently active child state."]}),"\n",(0,a.jsx)(t.h2,{id:"initial-state",children:"Initial state"}),"\n",(0,a.jsxs)(t.p,{children:["When a state machine starts, it enters the ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/initial-states",children:(0,a.jsx)(t.strong,{children:"initial state"})})," first. A machine can only have one top-level initial state."]}),"\n",(0,a.jsx)(t.h2,{id:"invoked-actors",children:"Invoked actors"}),"\n",(0,a.jsxs)(t.p,{children:["An ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/actors",children:"invoked actor"})," is an actor that can execute its own actions and communicate with the machine. These invoked actors are started in a state and stopped when the state is exited."]}),"\n",(0,a.jsx)(t.h2,{id:"parallel-states",children:"Parallel states"}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/parallel-states",children:"parallel state"})," is a state separated into multiple regions of child states, where each region is active simultaneously."]}),"\n",(0,a.jsx)(t.h2,{id:"parent-and-child-states",children:"Parent and child states"}),"\n",(0,a.jsxs)(t.p,{children:["States can contain more states, also known as\xa0",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/parent-states",children:"child states"}),". These child states are only active when the parent state is active. Child states are nested inside their parent states. Parent states are also known as compound states."]}),"\n",(0,a.jsx)(t.h2,{id:"states",children:"States"}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/states",children:"state"})," describes the status of the machine. A state can be as simple as ",(0,a.jsx)(t.em,{children:"active"})," and ",(0,a.jsx)(t.em,{children:"inactive"}),". These states are finite; the machine can only move through the pre-defined states. A state machine can only be in one state at a time."]}),"\n",(0,a.jsx)(t.h2,{id:"statecharts",children:"Statecharts"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/xstate-zh/docs/state-machines-and-statecharts",children:"Statecharts"})," are a visual extension to state machines enabling you to model more complex logic, including hierarchy, concurrency, and communication."]}),"\n",(0,a.jsx)(t.h2,{id:"state-machines",children:"State machines"}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/state-machines-and-statecharts",children:"state machine"})," is a model that describes how the state of a process transitions to another state when an event occurs. State machines make building reliable software easier because they prevent impossible states and undesired transitions. When you run a state machine, it becomes an ",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/actors",children:"actor"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"transitions-and-events",children:"Transitions and events"}),"\n",(0,a.jsxs)(t.p,{children:["A machine moves from state to state through\xa0",(0,a.jsx)(t.a,{href:"/xstate-zh/docs/transitions",children:"transitions"}),". Transitions are caused by events; when an event happens, the machine transitions to the next state. Transitions are \u201cdeterministic\u201d; each combination of state and event always points to the same next state."]})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>r});var a=s(67294);const n={},i=a.createContext(n);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);