"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[3682],{89716:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>o});var s=n(85893),i=n(11151);const a={title:"@xstate/test"},d=void 0,l={id:"xstate-test",title:"@xstate/test",description:"The latest version of the model-based testing utilities (prev. @xstate/test) are now part of the latest @xstate/graph package.",source:"@site/docs/xstate-test.mdx",sourceDirName:".",slug:"/xstate-test",permalink:"/xstate-zh/docs/xstate-test",draft:!1,unlisted:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/xstate-test.mdx",tags:[],version:"current",frontMatter:{title:"@xstate/test"},sidebar:"tutorialSidebar",previous:{title:"@xstate/graph",permalink:"/xstate-zh/docs/xstate-graph"},next:{title:"\u5f00\u53d1\u8005\u5de5\u5177",permalink:"/xstate-zh/docs/category/developer-tools"}},r={},o=[{value:"Quick start",id:"quick-start",level:2},{value:"API",id:"api",level:2},{value:"<code>createModel(machine, options?)</code>",id:"createmodelmachine-options",level:3},{value:"Returns",id:"returns",level:4},{value:"Methods",id:"methods",level:3},{value:"<code>model.withEvents(eventsMap)</code>",id:"modelwitheventseventsmap",level:4},{value:"<code>testModel.getShortestPathPlans(options?)</code>",id:"testmodelgetshortestpathplansoptions",level:3},{value:"Options",id:"options",level:4},{value:"<code>testModel.getSimplePathPlans(options?)</code>",id:"testmodelgetsimplepathplansoptions",level:3},{value:"Options",id:"options-1",level:4},{value:"<code>testModel.getPlanFromEvents(events, options)</code>",id:"testmodelgetplanfromeventsevents-options",level:3},{value:"<code>testModel.testCoverage(options?)</code>",id:"testmodeltestcoverageoptions",level:3},{value:"Options",id:"options-2",level:4},{value:"<code>testPlan.description</code>",id:"testplandescription",level:3},{value:"<code>testPlan.paths</code>",id:"testplanpaths",level:3},{value:"<code>testPath.description</code>",id:"testpathdescription",level:3},{value:"<code>testPath.test(testContext)</code>",id:"testpathtesttestcontext",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.admonition,{type:"warningxstate",children:[(0,s.jsxs)(t.p,{children:["The latest version of the model-based testing utilities (prev. ",(0,s.jsx)(t.code,{children:"@xstate/test"}),") are now part of the latest ",(0,s.jsx)(t.code,{children:"@xstate/graph"})," package."]}),(0,s.jsxs)(t.p,{children:["Documentation for ",(0,s.jsx)(t.code,{children:"@xstate/graph"})," (including the testing utilities) is coming soon; the documentation below is for ",(0,s.jsx)(t.code,{children:"@xstate/test@beta"}),"."]})]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"https://github.com/statelyai/xstate/tree/main/packages/xstate-test",children:"@xstate/test package"})," contains utilities for facilitating ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Model-based_testing",children:"model-based testing"})," for any software."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Watch the talk"}),": ",(0,s.jsx)(t.a,{href:"https://slides.com/davidkhourshid/mbt",children:"Write Fewer Tests! From Automation to Autogeneration"})," at React Rally 2019 (",(0,s.jsxs)(t.a,{href:"https://www.youtube.com/watch?v=tpNmPKjPSFQ",children:[(0,s.jsx)(t.span,{role:"img","aria-label":"movie camera",children:"\ud83c\udfa5"})," Video"]}),")"]}),"\n",(0,s.jsx)(t.h2,{id:"quick-start",children:"Quick start"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Install ",(0,s.jsx)(t.code,{children:"xstate"})," and ",(0,s.jsx)(t.code,{children:"@xstate/test"}),":"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"npm install xstate @xstate/test\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsx)(t.li,{children:"Create the machine that will be used to model the system under test (SUT):"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { createMachine } from 'xstate';\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: {\n      on: {\n        TOGGLE: 'active',\n      },\n    },\n    active: {\n      on: {\n        TOGGLE: 'inactive',\n      },\n    },\n  },\n});\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"3",children:["\n",(0,s.jsxs)(t.li,{children:["Add assertions for each state in the machine (in this example, using ",(0,s.jsx)(t.a,{href:"https://github.com/GoogleChrome/puppeteer",children:"Puppeteer"}),"):"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// ...\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: {\n      on: {\n        /* ... */\n      },\n      meta: {\n        test: async (page) => {\n          await page.waitFor('input:checked');\n        },\n      },\n    },\n    active: {\n      on: {\n        /* ... */\n      },\n      meta: {\n        test: async (page) => {\n          await page.waitFor('input:not(:checked)');\n        },\n      },\n    },\n  },\n});\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"4",children:["\n",(0,s.jsx)(t.li,{children:"Create the model:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { createMachine } from 'xstate';\nimport { createModel } from '@xstate/test';\n\nconst toggleMachine = createMachine(/* ... */);\n\nconst toggleModel = createModel(toggleMachine).withEvents({\n  TOGGLE: {\n    exec: async (page) => {\n      await page.click('input');\n    },\n  },\n});\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"5",children:["\n",(0,s.jsx)(t.li,{children:"Create test plans and run the tests with coverage:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// ...\n\ndescribe('toggle', () => {\n  const testPlans = toggleModel.getShortestPathPlans();\n\n  testPlans.forEach((plan) => {\n    describe(plan.description, () => {\n      plan.paths.forEach((path) => {\n        it(path.description, async () => {\n          // do any setup, then...\n\n          await path.test(page);\n        });\n      });\n    });\n  });\n\n  it('should have full coverage', () => {\n    return toggleModel.testCoverage();\n  });\n});\n"})}),"\n",(0,s.jsx)(t.h2,{id:"api",children:"API"}),"\n",(0,s.jsx)(t.h3,{id:"createmodelmachine-options",children:(0,s.jsx)(t.code,{children:"createModel(machine, options?)"})}),"\n",(0,s.jsxs)(t.p,{children:["Creates an abstract testing model based on the ",(0,s.jsx)(t.code,{children:"machine"})," passed in."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Argument"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"machine"})}),(0,s.jsx)(t.td,{children:"StateMachine"}),(0,s.jsx)(t.td,{children:"The machine used to create the abstract model."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"options?"})}),(0,s.jsx)(t.td,{children:"TestModelOptions"}),(0,s.jsx)(t.td,{children:"Options to customize the abstract model"})]})]})]}),"\n",(0,s.jsx)(t.h4,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.code,{children:"TestModel"})," instance."]}),"\n",(0,s.jsx)(t.h3,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.h4,{id:"modelwitheventseventsmap",children:(0,s.jsx)(t.code,{children:"model.withEvents(eventsMap)"})}),"\n",(0,s.jsxs)(t.p,{children:["Provides testing details for each event. Each key in ",(0,s.jsx)(t.code,{children:"eventsMap"})," is an object whose keys are event types and properties describe the execution and test cases for each event:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"exec"})," (function): Function that executes the events. It is given two arguments:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"testContext"})," (any): any contextual testing data"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"event"})," (EventObject): the event sent by the testing model"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"cases?"})," (EventObject[]): the sample event objects for this event type that can be sent by the testing model."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const toggleModel = createModel(toggleMachine).withEvents({\n  TOGGLE: {\n    exec: async (page) => {\n      await page.click('input');\n    },\n  },\n});\n"})}),"\n",(0,s.jsx)(t.h3,{id:"testmodelgetshortestpathplansoptions",children:(0,s.jsx)(t.code,{children:"testModel.getShortestPathPlans(options?)"})}),"\n",(0,s.jsx)(t.p,{children:"Returns an array of testing plans based on the shortest paths from the test model\u2019s initial state to every other reachable state."}),"\n",(0,s.jsx)(t.h4,{id:"options",children:"Options"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Argument"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"filter"})}),(0,s.jsx)(t.td,{children:"function"}),(0,s.jsxs)(t.td,{children:["Takes in the ",(0,s.jsx)(t.code,{children:"state"})," and returns ",(0,s.jsx)(t.code,{children:"true"})," if the state should be traversed, or ",(0,s.jsx)(t.code,{children:"false"})," if traversal should stop."]})]})})]}),"\n",(0,s.jsx)(t.p,{children:"This is useful for preventing infinite traversals and stack overflow errors:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const todosModel = createModel(todosMachine).withEvents({\n  /* ... */\n});\n\nconst plans = todosModel.getShortestPathPlans({\n  // Tell the algorithm to limit state/event adjacency map to states\n  // that have less than 5 todos\n  filter: (state) => state.context.todos.length < 5,\n});\n"})}),"\n",(0,s.jsx)(t.h3,{id:"testmodelgetsimplepathplansoptions",children:(0,s.jsx)(t.code,{children:"testModel.getSimplePathPlans(options?)"})}),"\n",(0,s.jsx)(t.p,{children:"Returns an array of testing plans based on the simple paths from the test model\u2019s initial state to every other reachable state."}),"\n",(0,s.jsx)(t.h4,{id:"options-1",children:"Options"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Argument"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"filter"})}),(0,s.jsx)(t.td,{children:"function"}),(0,s.jsxs)(t.td,{children:["Takes in the ",(0,s.jsx)(t.code,{children:"state"})," and returns ",(0,s.jsx)(t.code,{children:"true"})," if the state should be traversed, or ",(0,s.jsx)(t.code,{children:"false"})," if traversal should stop."]})]})})]}),"\n",(0,s.jsx)(t.h3,{id:"testmodelgetplanfromeventsevents-options",children:(0,s.jsx)(t.code,{children:"testModel.getPlanFromEvents(events, options)"})}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Argument"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"events"})}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"EventObject[]"})}),(0,s.jsx)(t.td,{children:"The sequence of events to create the plan"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"options"})}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"{ target: string }"})}),(0,s.jsxs)(t.td,{children:["An object with a ",(0,s.jsx)(t.code,{children:"target"})," property that should match the target state of the events"]})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["Returns an array with a single testing plan with a single path generated from the ",(0,s.jsx)(t.code,{children:"events"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Throws an error if the last entered state does not match the ",(0,s.jsx)(t.code,{children:"options.target"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"testmodeltestcoverageoptions",children:(0,s.jsx)(t.code,{children:"testModel.testCoverage(options?)"})}),"\n",(0,s.jsx)(t.p,{children:"Tests that all state nodes were covered (traversed) in the exected tests."}),"\n",(0,s.jsx)(t.h4,{id:"options-2",children:"Options"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Argument"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"filter"})}),(0,s.jsx)(t.td,{children:"function"}),(0,s.jsxs)(t.td,{children:["Takes in each ",(0,s.jsx)(t.code,{children:"stateNode"})," and returns ",(0,s.jsx)(t.code,{children:"true"})," if that state node should have been covered."]})]})})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// Only test coverage for state nodes with a `.meta` property defined:\n\ntestModel.testCoverage({\n  filter: (stateNode) => !!stateNode.meta,\n});\n"})}),"\n",(0,s.jsx)(t.h3,{id:"testplandescription",children:(0,s.jsx)(t.code,{children:"testPlan.description"})}),"\n",(0,s.jsxs)(t.p,{children:["The string description of the testing plan, describing the goal of reaching the ",(0,s.jsx)(t.code,{children:"testPlan.state"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"testplanpaths",children:(0,s.jsx)(t.code,{children:"testPlan.paths"})}),"\n",(0,s.jsx)(t.p,{children:"The testing paths to get from the test model\u2019s initial state to every other reachable state."}),"\n",(0,s.jsx)(t.h3,{id:"testpathdescription",children:(0,s.jsx)(t.code,{children:"testPath.description"})}),"\n",(0,s.jsxs)(t.p,{children:["The string description of the testing path, describing a sequence of events that will reach the ",(0,s.jsx)(t.code,{children:"testPath.state"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"testpathtesttestcontext",children:(0,s.jsx)(t.code,{children:"testPath.test(testContext)"})}),"\n",(0,s.jsxs)(t.p,{children:["Executes each step in ",(0,s.jsx)(t.code,{children:"testPath.segments"})," by:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Verifying that the SUT is in ",(0,s.jsx)(t.code,{children:"segment.state"})]}),"\n",(0,s.jsxs)(t.li,{children:["Executing the event for ",(0,s.jsx)(t.code,{children:"segment.event"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["And finally, verifying that the SUT is in the target ",(0,s.jsx)(t.code,{children:"testPath.state"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["NOTE: If your model has nested states, the ",(0,s.jsx)(t.code,{children:"meta.test"})," method for each parent state of that nested state is also executed when verifying that the SUT is in that nested state."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>d});var s=n(67294);const i={},a=s.createContext(i);function d(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);