"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[1919],{10347:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=t(85893),s=t(11151);const i={title:"AI Agents"},r=void 0,o={id:"agents",title:"AI Agents",description:"An AI agent is an autonomous entity that observes an environment, decides what to do (based on its internal policy), and performs actions towards achieving its goals. In terms of the actor model, an agent can be considered an actor that can:",source:"@site/docs/agents.mdx",sourceDirName:".",slug:"/agents",permalink:"/xstate-zh/docs/agents",draft:!1,unlisted:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/agents.mdx",tags:[],version:"current",frontMatter:{title:"AI Agents"},sidebar:"tutorialSidebar",previous:{title:"\u4ee3\u7406",permalink:"/xstate-zh/docs/category/agents"},next:{title:"\u6307\u5357",permalink:"/xstate-zh/docs/category/guides"}},c={},d=[{value:"Installation",id:"installation",level:2},{value:"Quick start",id:"quick-start",level:2},{value:"Creating an agent",id:"creating-an-agent",level:2},{value:"Making decisions",id:"making-decisions",level:2},{value:"Agent memory",id:"agent-memory",level:2},{value:"Messages",id:"messages",level:2},{value:"<code>agent.getMessages()</code>",id:"agentgetmessages",level:3},{value:"<code>agent.addMessage(message)</code>",id:"agentaddmessagemessage",level:3},{value:"Observations",id:"observations",level:2},{value:"<code>agent.getObservations()</code>",id:"agentgetobservations",level:3},{value:"<code>agent.addObservation(observation)</code>",id:"agentaddobservationobservation",level:3},{value:"Feedback",id:"feedback",level:2},{value:"<code>agent.getFeedback()</code>",id:"agentgetfeedback",level:3},{value:"<code>agent.addFeedback(feedback)</code>",id:"agentaddfeedbackfeedback",level:3},{value:"Plans",id:"plans",level:2},{value:"<code>agent.getPlans()</code>",id:"agentgetplans",level:3},{value:"<code>agent.addPlan(plan)</code>",id:"agentaddplanplan",level:3},{value:"Interacting with state machines",id:"interacting-with-state-machines",level:2},{value:"State machine agents",id:"state-machine-agents",level:2},{value:"<code>fromDecision(agent)</code>",id:"fromdecisionagent",level:3},{value:"<code>fromText(agent)</code>",id:"fromtextagent",level:3},{value:"<code>fromTextStream(agent)</code>",id:"fromtextstreamagent",level:3},{value:"Observability",id:"observability",level:2},{value:"Generating text",id:"generating-text",level:2},{value:"Streaming text",id:"streaming-text",level:2},{value:"Agent logic",id:"agent-logic",level:2},{value:"Examples",id:"examples",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{TabItem:t,Tabs:i}=n;return t||g("TabItem",!0),i||g("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"An AI agent is an autonomous entity that observes an environment, decides what to do (based on its internal policy), and performs actions towards achieving its goals. In terms of the actor model, an agent can be considered an actor that can:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Receive events"}),", such as an instruction on what to do next, which goal to accomplish, or an observation of the environment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Send events"}),", which would cause actions to be performed on the environment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Store state"}),", which can be used to remember contextual information about the environment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Spawn other agents"}),", which can be used to create a hierarchy of agents that can work together and coordinate their actions to achieve a goal"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsxs)(n.a,{href:"https://github.com/statelyai/agent",children:["Stately Agent (",(0,a.jsx)(n.code,{children:"@statelyai/agent"}),")"]})," package makes it simple to create agents and agent behavior based on the actor model and state machines. These agents can do much more than generate text and execute function calls; Stately Agent is a framework for:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Storing message history"})," between the user and assistant when using the generative text features"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Making observations"})," of an environment, recording the transitions (previous state, event, next state) so it can understand the environment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Receiving feedback"})," on decisions it makes, so it can retrieve and corrolate feedback so that it can make more informed decisions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Making plans"})," in its decision-making progress, so that it not only predicts the very next decision to make, but a sequence of decisions that ideally reaches the goal"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Short-term and long-term memory"})," for remembering message history, observations, feedback, and plans that it makes."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(n.p,{children:"Install the following dependencies:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@statelyai/agent@beta"})," \u2013\xa0Stately.ai Agent, currently in beta"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@ai-sdk/openai"})," \u2013\xa0The Vercel AI SDK for OpenAI, which provides access to the OpenAI API"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"xstate"})," \u2013 Library for managing state machines and statecharts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"zod"})," \u2013 Library for type-safe schema validation"]}),"\n"]}),"\n",(0,a.jsxs)(i,{children:[(0,a.jsx)(t,{value:"npm",label:"npm",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm install @statelyai/agent @ai-sdk/openai xstate zod \n"})})}),(0,a.jsx)(t,{value:"pnpm",label:"pnpm",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"pnpm install @statelyai/agent @ai-sdk/openai xstate zod \n"})})}),(0,a.jsx)(t,{value:"yarn",label:"yarn",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"yarn add @statelyai/agent @ai-sdk/openai xstate zod \n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"quick-start",children:"Quick start"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Add your provider's API key to your ",(0,a.jsx)(n.code,{children:".env"})," file."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'OPENAI_API_KEY="sk-abCDE..."\n'})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"Create an agent."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { openai } from '@ai-sdk/openai';\nimport { createAgent } from '@statelyai/agent';\n\nconst agent = createAgent({\n  name: 'todo',\n  model: openai('gpt-4-turbo'),\n  events: {}\n});\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsx)(n.li,{children:'Add event schemas using Zod. These are the events that the agent is allowed to "cause" (i.e. send to the actor)'}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { openai } from '@ai-sdk/openai';\nimport { createAgent } from '@statelyai/agent';\nimport { z } from 'zod';\n\nconst agent = createAgent({\n  model: openai('gpt-4-turbo'),\n  name: 'todo',\n  // highlight-start\n  events: {\n    'todo.add': z.object({\n      todo: z\n        .object({\n          title: z.string().describe('The title of the todo'),\n          content: z.string().describe('The content of the todo'),\n          completed: z\n            .boolean()\n            .describe('The completed value of the todo')\n            .optional(),\n        })\n        .describe('Adds a new todo'),\n    }),\n    'todo.toggle': z.object({\n      todoId: z.string().describe('The ID of the todo to toggle'),\n      completed: z.boolean().describe('The new completed value').optional(),\n    }),\n  }\n  // highlight-end\n});\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsxs)(n.li,{children:["Interact with a ",(0,a.jsx)(n.a,{href:"/xstate-zh/docs/state-machine-actors",children:"state machine actor"})," that accepts those events."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { setup, createActor } from 'xstate';\n// highlight-next-line\nimport { agent } from './agent';\n\nconst todoMachine = setup({\n  types: {\n    // highlight-start\n    // Add the event types that the agent understands\n    events: agent.types.events\n    // highlight-end\n  },\n  // ...\n}).createMachine({\n  // ...\n});\n\nconst todoActor = createActor(todoMachine);\n\n// highlight-next-line\nagent.interact(todoMachine);\n\ntodoActor.start();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-an-agent",children:"Creating an agent"}),"\n",(0,a.jsxs)(n.p,{children:["You can create an agent using the ",(0,a.jsx)(n.code,{children:"createAgent(settings)"})," function. There are required settings:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"name"})," - The name of the agent, used for logging and agent learning purposes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"model"})," - The ",(0,a.jsx)(n.a,{href:"https://sdk.vercel.ai/docs/foundations/providers-and-models",children:"AI SDK language model"})," to use for generating text and making tool calls"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"events"})," - A mapping of event types to ",(0,a.jsx)(n.a,{href:"https://zod.dev/",children:"Zod"})," event schemas that the agent can trigger (i.e. events it can send to some live environment that it is interacting with)"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createAgent } from '@statelyai/agent';\nimport { openai } from '@ai-sdk/openai';\nimport { z } from 'zod';\n\nconst agent = createAgent({\n  name: 'barista',\n  model: openai('gpt-4-turbo'),\n  events: {\n    'barista.makeDrink': z.object({\n      drink: z.enum(['espresso', 'latte', 'cappuccino']),\n    }).describe('Makes a drink'),\n    // ...\n  }\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can specify additional settings to customize the agent's behavior:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"description"})," - A description of the agent, used for logging and agent learning purposes, as well as for agents that call other agents (multi-agent systems)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"planner"})," - An async function that takes the ",(0,a.jsx)(n.code,{children:"agent"})," and planner ",(0,a.jsx)(n.code,{children:"input"})," and resolves with an ",(0,a.jsx)(n.code,{children:"AgentPlan"})," that potentially includes the ",(0,a.jsx)(n.code,{children:"steps"})," and the ",(0,a.jsx)(n.code,{children:"nextEvent"})," to execute to achieve the ",(0,a.jsx)(n.code,{children:"input.goal"}),". This function is used to determine what the agent should do next when making a decision based on the current state (",(0,a.jsx)(n.code,{children:"input.state"}),") and goal (",(0,a.jsx)(n.code,{children:"input.goal"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"logic"})," - The agent logic function that is used to determine what an agent does when it receives an agent event, such as ",(0,a.jsx)(n.code,{children:'"agent.feedback"'}),", ",(0,a.jsx)(n.code,{children:'"agent.observe"'}),", ",(0,a.jsx)(n.code,{children:'"agent.message"'}),", or ",(0,a.jsx)(n.code,{children:'"agent.plan"'}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"making-decisions",children:"Making decisions"}),"\n",(0,a.jsxs)(n.p,{children:["The most important feature of a Stately agent is the ability to make decisions based on the current state and goal. This is done using the ",(0,a.jsx)(n.code,{children:"agent.decide(input)"})," async function, which takes an ",(0,a.jsx)(n.code,{children:"input"})," object that contains the current state, state machine, and goal, and resolves with an ",(0,a.jsx)(n.code,{children:"AgentPlan"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, suppose you have the following ",(0,a.jsx)(n.code,{children:"baristaMachine"})," state machine:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createMachine } from 'xstate';\n\nexport const baristaMachine = createMachine({\n  initial: 'idle',\n  states: {\n    idle: {\n      on: {\n        'barista.makeDrink': 'makingDrink',\n      },\n    },\n    makingDrink: {\n      on: {\n        'barista.drinkMade': 'idle',\n      }\n    },\n  },\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can then use the ",(0,a.jsx)(n.code,{children:"agent.decide(input)"})," function to determine what the agent should do next:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createAgent } from '@statelyai/agent';\nimport { baristaMachine } from './baristaMachine';\n\nconst agent = createAgent({\n  name: 'barista',\n  model: openai('gpt-4-turbo'),\n  events: {\n    'barista.makeDrink': z.object({\n      drink: z.enum(['espresso', 'latte', 'cappuccino']),\n    }).describe('Makes a drink')\n  }\n});\n\nasync function handleOrder(order, state) {\n  const resolvedState = baristaMachine.resolveState(state)\n  // highlight-start\n  const plan = await agent.decide({\n    state: resolvedState,\n    machine: baristaMachine,\n    goal: `A customer made this order: ${order}`,\n  });\n  // highlight-end\n\n  return plan;\n}\n\nhandleOrder('I want a latte please', { value: 'idle' });\n// Resolves with an `AgentPlan` that includes:\n// {\n//   // ...\n//   nextEvent: { type: 'barista.makeDrink', drink: 'latte' },\n// }\n"})}),"\n",(0,a.jsx)(n.h2,{id:"agent-memory",children:"Agent memory"}),"\n",(0,a.jsxs)(n.p,{children:["Stately agents can have two types of memory: ",(0,a.jsx)(n.strong,{children:"short-term (local) memory"})," and ",(0,a.jsx)(n.strong,{children:"long-term memory"}),"."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Short-term (local) memory"})," is memory that can be synchronously retrieved, but might not be persisted."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Long-term memory"})," is memory that is asynchronously retrieved from persistent storage, such as a database."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Agents remember four kinds of things in their memory:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Messages"})," between the user and the assistant"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Observations"})," of state transitions (previous state, event, current state) that occur in the environment that the agent is observing"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Feedback"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Plans"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"messages",children:"Messages"}),"\n",(0,a.jsx)(n.h3,{id:"agentgetmessages",children:(0,a.jsx)(n.code,{children:"agent.getMessages()"})}),"\n",(0,a.jsx)(n.p,{children:"Returns chat messages that occur between the user and the assistant from short-term memory."}),"\n",(0,a.jsx)(n.h3,{id:"agentaddmessagemessage",children:(0,a.jsx)(n.code,{children:"agent.addMessage(message)"})}),"\n",(0,a.jsxs)(n.p,{children:["If you want to manually add a message between the assistant and user to agent memory, you can call ",(0,a.jsx)(n.code,{children:"agent.addMessage(message)"})," to do so. This is automatically called when calling ",(0,a.jsx)(n.code,{children:"agent.generateText(\u2026)"}),", ",(0,a.jsx)(n.code,{children:"agent.streamText(\u2026)"}),", or the ",(0,a.jsx)(n.code,{children:"fromText(\u2026)"})," and ",(0,a.jsx)(n.code,{children:"fromTextStream(\u2026)"})," actor logic creators. You should avoid calling this manually."]}),"\n",(0,a.jsx)(n.h2,{id:"observations",children:"Observations"}),"\n",(0,a.jsx)(n.h3,{id:"agentgetobservations",children:(0,a.jsx)(n.code,{children:"agent.getObservations()"})}),"\n",(0,a.jsx)(n.p,{children:"Returns observations that the agent observes from short-term memory."}),"\n",(0,a.jsx)(n.h3,{id:"agentaddobservationobservation",children:(0,a.jsx)(n.code,{children:"agent.addObservation(observation)"})}),"\n",(0,a.jsxs)(n.p,{children:["You can add an observation (",(0,a.jsx)(n.code,{children:"{ prevState, event, state, \u2026 }"}),") to an agent's memory by calling ",(0,a.jsx)(n.code,{children:"agent.addObservation(observation)"}),". This function returns an ",(0,a.jsx)(n.code,{children:"AgentObservation"})," object that includes the provided observation details as well as an observation ",(0,a.jsx)(n.code,{children:"id"})," so that the observation can be referenced in feedback, if applicable."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const observation = agent.addObservation({\n  prevState: { value: 'idle', context: {} },\n  event: { type: 'grindBeans' },\n  state: { value: 'grindingBeans', context: {} },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"feedback",children:"Feedback"}),"\n",(0,a.jsx)(n.h3,{id:"agentgetfeedback",children:(0,a.jsx)(n.code,{children:"agent.getFeedback()"})}),"\n",(0,a.jsx)(n.p,{children:"Returns feedback that is given to the agent from short-term memory."}),"\n",(0,a.jsx)(n.h3,{id:"agentaddfeedbackfeedback",children:(0,a.jsx)(n.code,{children:"agent.addFeedback(feedback)"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const observation = agent.addObservation({\n  // ...\n});\n\nconst feedback = agent.addFeedback({\n  observationId: observation.id,\n  goal: 'Make an iced coffee',\n  attributes: {\n    feedback: 'Water should not be boiled for an iced coffee',\n    score: -10\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"plans",children:"Plans"}),"\n",(0,a.jsx)(n.h3,{id:"agentgetplans",children:(0,a.jsx)(n.code,{children:"agent.getPlans()"})}),"\n",(0,a.jsx)(n.p,{children:"Returns plans that the agent has made from short-term memory."}),"\n",(0,a.jsx)(n.h3,{id:"agentaddplanplan",children:(0,a.jsx)(n.code,{children:"agent.addPlan(plan)"})}),"\n",(0,a.jsx)(n.p,{children:"TODO"}),"\n",(0,a.jsx)(n.h2,{id:"interacting-with-state-machines",children:"Interacting with state machines"}),"\n",(0,a.jsx)(n.p,{children:"An agent can interact with existing state machine actors to determine what to do next. While the state machine actor is running, the agent will do the following cycle:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["The agent ",(0,a.jsx)(n.strong,{children:"observes state changes"})]}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The observation is remembered in the agent's state"}),"\n"]}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsxs)(n.li,{children:["The agent ",(0,a.jsx)(n.strong,{children:"determines"})," if it needs to make a decision based on the current state"]}),"\n",(0,a.jsxs)(n.li,{children:["If it does, the agent ",(0,a.jsx)(n.strong,{children:"makes a decision"})," in the form of an ",(0,a.jsx)(n.code,{children:"AgentPlan"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["If an ",(0,a.jsx)(n.code,{children:"AgentPlan"})," is formed, the agent triggers the next event (",(0,a.jsx)(n.code,{children:"plan.nextEvent"}),") on the state machine actor."]}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The plan is remembered in the agent's state."}),"\n"]}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsx)(n.li,{children:"The agent goes back to step 1, and the cycle continues."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createAgent } from '@statelyai/agent';\nimport { createActor } from 'xstate';\nimport { jokeMachine } from './jokeMachine';\n\nconst agent = createAgent({\n  name: 'joke-teller',\n  model: openai('gpt-4'),\n  events: {\n    'agent.tellJoke': z.object({\n      joke: z.string().describe('The joke text'),\n    }),\n    'agent.rateJoke': z.object({\n      rating: z.number().min(1).max(10),\n      explanation: z.string(),\n    }),\n    // ...\n  }\n});\n\nconst jokeActor = createActor(jokeMachine).start();\n\nagent.interact(jokeActor, (observed) => {\n  if (observed.state.matches('tellingJoke')) {\n    return { goal: `Tell a joke about ${observed.state.context.topic}` };\n  }\n  if (observed.state.matches('ratingJoke')) {\n    return { goal: `Rate this joke: ${observed.state.context.joke}` };\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"state-machine-agents",children:"State machine agents"}),"\n",(0,a.jsxs)(n.p,{children:["You can invoke Stately agents as part of a state machine, ensuring that it will follow the state machine's transitions as specified and trigger the appropriate events. This is done by using any of the following ",(0,a.jsx)(n.a,{href:"/xstate-zh/docs/actors",children:"actor logic creators"}),":"]}),"\n",(0,a.jsx)(n.h3,{id:"fromdecisionagent",children:(0,a.jsx)(n.code,{children:"fromDecision(agent)"})}),"\n",(0,a.jsxs)(n.p,{children:["Returns ",(0,a.jsx)(n.a,{href:"TODO",children:"promise actor logic"})," that resolves with the ",(0,a.jsx)(n.strong,{children:"agent plan"})," that should accomplish the goal (",(0,a.jsx)(n.code,{children:"input.goal"}),"), if it is able to create one."]}),"\n",(0,a.jsx)(n.p,{children:"When invoked/spawned, this actor will also add the user and assistant messages to agent memory, as well as the plan that it created."}),"\n",(0,a.jsx)(n.h3,{id:"fromtextagent",children:(0,a.jsx)(n.code,{children:"fromText(agent)"})}),"\n",(0,a.jsxs)(n.p,{children:["Returns ",(0,a.jsx)(n.a,{href:"TODO",children:"promise actor logic"})," that resolves with the generated text result from the ",(0,a.jsx)(n.a,{href:"https://sdk.vercel.ai/docs/reference/ai-sdk-core/generate-text#generatetext",children:"Vercel AI SDK"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"When invoked/spawned, this actor will also add the user and assistant messages to agent memory."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { createAgent, fromText } from '@statelyai/agent';\nimport { setup } from 'xstate';\n\nconst agent = createAgent(/* ... */);\n\nconst machine = setup({\n  actors: {\n    assistant: fromText(agent),\n  }\n}).createMachine({\n  initial: 'greeting',\n  context: x => ({\n    time: x.input.time\n  }),\n  states: {\n    greeting: {\n      invoke: {\n        src: 'assistant',\n        input: ({ context }) => ({\n          context: {\n            time: context.time\n          },\n          goal: 'Produce a greeting depending on the time of day.'\n        }),\n        onDone: {\n          target: 'greeted',\n          actions: ({ event }) => {\n            console.log(event.output.text);\n          }\n        },\n      },\n    },\n    greeted: {\n      type: 'final'\n    }\n  }\n});\n\nconst actor = createActor(machine, {\n  input: { time: Date.now() }\n});\n\nactor.start();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"fromtextstreamagent",children:(0,a.jsx)(n.code,{children:"fromTextStream(agent)"})}),"\n",(0,a.jsxs)(n.p,{children:["Returns ",(0,a.jsx)(n.a,{href:"TODO",children:"observable actor logic"})," that streams the text from the ",(0,a.jsx)(n.a,{href:"https://sdk.vercel.ai/docs/reference/ai-sdk-core/stream-text",children:"Vercel AI SDK"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"When invoked/spawned, this actor will also add the user and assistant messages to agent memory."}),"\n",(0,a.jsx)(n.p,{children:"TODO: example"}),"\n",(0,a.jsx)(n.h2,{id:"observability",children:"Observability"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Can observe observations, plans, messages, and feedback via ",(0,a.jsx)(n.code,{children:"agent.on('message', (message) => {})"})]}),"\n",(0,a.jsxs)(n.li,{children:["Can manually add feedback observations via ",(0,a.jsx)(n.code,{children:"agent.addFeedback(\u2026)"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"generating-text",children:"Generating text"}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"agent.generateText(input)"})," method to generate text from an input. This extends the ",(0,a.jsx)(n.code,{children:"generateText(\u2026)"})," function from the ",(0,a.jsx)(n.a,{href:"https://sdk.vercel.ai/docs/reference/ai-sdk-core/generate-text#generatetext",children:"Vercel AI SDK"})," by:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adding the user and assistant messages to agent memory"}),"\n",(0,a.jsx)(n.li,{children:"Providing the ability to retrieve previous observations, feedback, plans and messages from agent memory"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"streaming-text",children:"Streaming text"}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"agent.streamText(input)"})," method to stream text from an input. This extends the ",(0,a.jsx)(n.code,{children:"streamText(\u2026)"})," function from the ",(0,a.jsx)(n.a,{href:"https://sdk.vercel.ai/docs/reference/ai-sdk-core/generate-text#generatetext",children:"Vercel AI SDK"})," by:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adding the user and assistant messages to agent memory"}),"\n",(0,a.jsx)(n.li,{children:"Providing the ability to retrieve previous observations, feedback, plans and messages from agent memory"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"agent-logic",children:"Agent logic"}),"\n",(0,a.jsxs)(n.p,{children:["Agent logic is ",(0,a.jsx)(n.a,{href:"TODO",children:"actor logic"})," that has the specific purpose of performing LLM tasks for the agent. Agent logic goes beyond just being a wrapper and provides the ability to use the agent's state machine to intelligently determine which action to take next."]}),"\n",(0,a.jsx)(n.p,{children:"Agent logic is most powerful when used with a state-machine-powered agent, but you can also create standalone actors from agent logic, which is useful for testing and simple tasks."}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsxs)(n.p,{children:["See the current examples in the ",(0,a.jsx)(n.a,{href:"https://github.com/statelyai/agent/tree/main/examples",children:"examples directory"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}function g(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var a=t(67294);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);