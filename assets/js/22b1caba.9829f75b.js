"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[4231],{48370:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var n=s(85893),r=s(11151);const a={title:"Persistence"},o=void 0,i={id:"persistence",title:"Persistence",description:"Actors can persist their internal state and restore it later. Persistence refers to storing the state of an actor in persistent storage, such as localStorage or a database. Restoration refers to restoring the state of an actor from persistent storage.",source:"@site/docs/persistence.mdx",sourceDirName:".",slug:"/persistence",permalink:"/xstate-zh/docs/persistence",draft:!1,unlisted:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/persistence.mdx",tags:[],version:"current",frontMatter:{title:"Persistence"},sidebar:"tutorialSidebar",previous:{title:"History states",permalink:"/xstate-zh/docs/history-states"},next:{title:"Tags",permalink:"/xstate-zh/docs/tags"}},c={},l=[{value:"Persisting state",id:"persisting-state",level:2},{value:"Restoring state",id:"restoring-state",level:2},{value:"Deep persistence",id:"deep-persistence",level:2},{value:"Persisting state machine values",id:"persisting-state-machine-values",level:2},{value:"Event sourcing",id:"event-sourcing",level:2},{value:"Caveats",id:"caveats",level:2},{value:"Persistence cheatsheet",id:"persistence-cheatsheet",level:2},{value:"Cheatsheet: persisting state",id:"cheatsheet-persisting-state",level:3},{value:"Cheatsheet: restoring state",id:"cheatsheet-restoring-state",level:3},{value:"Resources",id:"resources",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"/xstate-zh/docs/actors",children:"Actors"})," can persist their internal state and restore it later. ",(0,n.jsx)(t.strong,{children:"Persistence"})," refers to storing the state of an actor in persistent storage, such as localStorage or a database. ",(0,n.jsx)(t.strong,{children:"Restoration"})," refers to restoring the state of an actor from persistent storage."]}),"\n",(0,n.jsx)(t.p,{children:"In frontend applications, persistence is useful for maintaining state across browser reloads. In backend applications, persistence allows workflows to span multiple requests, survive service restarts, be fault-tolerant, represent long-running processes, and be auditable and traceable."}),"\n",(0,n.jsxs)(t.p,{children:["In XState, you can obtain the snapshot (state) to be persisted via ",(0,n.jsx)(t.code,{children:"actor.getPersistedSnapshot()"})," and restore it via ",(0,n.jsx)(t.code,{children:"createActor(behavior, { snapshot: restoredState }).start()"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const feedbackActor = createActor(feedbackMachine).start();\n\n// Get state to be persisted\nconst persistedState = feedbackActor.getPersistedSnapshot();\n\n// Persist state\nlocalStorage.setItem('feedback', JSON.stringify(persistedState));\n\n// Restore state\nconst restoredState = JSON.parse(localStorage.getItem('feedback'));\n\nconst restoredFeedbackActor = createActor(feedbackMachine, {\n  snapshot: restoredState,\n}).start();\n"})}),"\n",(0,n.jsx)(t.h2,{id:"persisting-state",children:"Persisting state"}),"\n",(0,n.jsxs)(t.p,{children:["You can obtain the state to be persisted via ",(0,n.jsx)(t.code,{children:"actor.getPersistedSnapshot()"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const feedbackActor = createActor(feedbackMachine).start();\n\n// Get state to be persisted\nconst persistedState = feedbackActor.getPersistedSnapshot();\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The internal state can be persisted from any actor, not only machines. Note that the persisted state is ",(0,n.jsx)(t.em,{children:"not"})," the same as the snapshot from ",(0,n.jsx)(t.code,{children:"actor.getSnapshot()"}),"; persisted state represents the internal state of the actor, while snapshots represent the actor's last emitted value:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const promiseActor = fromPromise(() => Promise.resolve(42));\n\n// Get the last emitted value\nconst snapshot = promiseActor.getSnapshot();\nconsole.log(snapshot);\n// logs 42\n\n// Get the persisted state\nconst persistedState = promiseActor.getPersistedSnapshot();\nconsole.log(persistedState);\n// logs { status: 'done', data: 42 }\n"})}),"\n",(0,n.jsx)(t.h2,{id:"restoring-state",children:"Restoring state"}),"\n",(0,n.jsxs)(t.p,{children:["You can restore an actor to a persisted state by passing the persisted state into the ",(0,n.jsx)(t.code,{children:"state"})," option of the second argument of ",(0,n.jsx)(t.code,{children:"createActor(logic, { snapshot: restoredState })"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"// Get persisted state\nconst restoredState = JSON.parse(localStorage.getItem('feedback'));\n\n// Restore state\nconst feedbackActor = createActor(feedbackMachine, {\n  snapshot: restoredState,\n});\n\nfeedbackActor.start();\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Actions from machine actors will ",(0,n.jsx)(t.em,{children:"not"})," be re-executed, because they are assumed to have been already executed. However, invocations will be restarted, and spawned actors will be restored recursively."]}),"\n",(0,n.jsx)(t.h2,{id:"deep-persistence",children:"Deep persistence"}),"\n",(0,n.jsxs)(t.p,{children:["Persisting & restoring state from machine actors is deep; all ",(0,n.jsx)(t.a,{href:"/xstate-zh/docs/invoke",children:"invoked"})," & ",(0,n.jsx)(t.a,{href:"/xstate-zh/docs/spawn",children:"spawned actors"})," will be persisted and restored recursively."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const feedbackMachine = createMachine({\n  // ...\n  states: {\n    form: {\n      invoke: {\n        id: 'form',\n        src: formMachine,\n      },\n    },\n  },\n});\n\nconst feedbackActor = createActor(feedbackMachine).start();\n\n// Persist state\nconst persistedState = feedbackActor.getPersistedSnapshot();\nlocalStorage.setItem('feedback', JSON.stringify(persistedState));\n\n//  ...\n\n// Restore state\nconst restoredState = JSON.parse(localStorage.getItem('feedback'));\n\nconst restoredFeedbackActor = createActor(feedbackMachine, {\n  snapshot: restoredState,\n}).start();\n// Will restore both the feedbackActor and the invoked form actor at\n// their persisted states\n"})}),"\n",(0,n.jsx)(t.h2,{id:"persisting-state-machine-values",children:"Persisting state machine values"}),"\n",(0,n.jsxs)(t.p,{children:["If you want to persist only the finite state ",(0,n.jsx)(t.code,{children:"value"})," (and optionally the ",(0,n.jsx)(t.code,{children:"context"}),") of a state machine actor, you can use the ",(0,n.jsx)(t.code,{children:"machine.resolveState(...)"})," method:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import { someMachine } from './someMachine';\n\nconst restoredStateValue = localStorage.getItem('someState');\n// Assume that this is \"pending\"\n\n// highlight-start\nconst resolvedState = someMachine.resolveState({\n  value: restoredStateValue,\n  // context: { ... }\n});\n// highlight-end\n\n// Restore the actor\nconst restoredActor = createActor(someMachine, {\n  // highlight-next-line\n  snapshot: resolvedState\n});\n\nrestoredActor.start();\n"})}),"\n",(0,n.jsx)(t.h2,{id:"event-sourcing",children:"Event sourcing"}),"\n",(0,n.jsxs)(t.p,{children:["An alternative to persisting state is ",(0,n.jsx)(t.strong,{children:"event sourcing"}),", which is a way of restoring the state of an actor by replaying the ",(0,n.jsx)(t.a,{href:"/xstate-zh/docs/transitions",children:"events"})," that led to that state. Event sourcing can be more reliable than persisting state, because it is less prone to ",(0,n.jsx)(t.a,{href:"#caveats",children:"incompatible state"})," and it also allows you to replay actions."]}),"\n",(0,n.jsxs)(t.p,{children:["One way to implement event sourcing is to persist the events as they happen using the ",(0,n.jsx)(t.a,{href:"/docs/inspection",children:"inspection API"}),", and then replay them to restore the state of the actor:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const events = [];\n\nconst someActor = createActor(someMachine, {\n  // Inspect and persist events\n  inspect: (inspectionEvent) => {\n    if (inspectionEvent.type === '@xstate.event') {\n      const event = inspectionEvent.event;\n\n      // Only listen for events sent to the root actor\n      if (inspectionEvent.actorRef !== someActor) { return; }\n\n      // highlight-next-line\n      events.push(event);\n    }\n  }\n});\n\nsomeActor.start();\n\n// ...\n\n// Assuming the events are stored somewhere, e.g. in localStorage,\n// you can replay them to restore the state of the actor\n\nconst restoredActor = createActor(someMachine);\nrestoredActor.start();\n\n// highlight-start\nfor (const event of events) {\n  // Replay events\n  restoredActor.send(event);\n}\n// highlight-end\n"})}),"\n",(0,n.jsx)(t.h2,{id:"caveats",children:"Caveats"}),"\n",(0,n.jsx)(t.p,{children:"There are some caveats to persisting and restoring state that you should be aware of:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Incompatible state: if the machine or actor logic changes, the restored state may be incompatible with the new logic."}),"\n",(0,n.jsxs)(t.li,{children:["Replaying actions: actions that have already been executed will not be re-executed. ",(0,n.jsx)(t.a,{href:"#event-sourcing",children:"Event sourcing"})," is preferred for this use-case."]}),"\n",(0,n.jsx)(t.li,{children:"Serialization: the state must be serializable, which means that it must be JSON-serializable. This means that you cannot persist functions, classes, or other non-serializable values."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"persistence-cheatsheet",children:"Persistence cheatsheet"}),"\n",(0,n.jsx)(t.h3,{id:"cheatsheet-persisting-state",children:"Cheatsheet: persisting state"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const persistedState = actor.getPersistedSnapshot();\n"})}),"\n",(0,n.jsx)(t.h3,{id:"cheatsheet-restoring-state",children:"Cheatsheet: restoring state"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const restoredState = JSON.parse(localStorage.getItem('feedback'));\n\nconst restoredActor = createActor(actorMachine, {\n  snapshot: restoredState,\n}).start();\n"})}),"\n",(0,n.jsx)(t.h2,{id:"resources",children:"Resources"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/blog/2023-10-02-persisting-state",children:"Blog: Persisting state in XState"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>i,a:()=>o});var n=s(67294);const r={},a=n.createContext(r);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);